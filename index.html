<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/catppuccin.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
    <style>
        .fragment.blur {
            filter: blur(100px);
        }

        .fragment.blur.visible {
            filter: none;
        }

        .reveal pre code {
            display: block; /* Ensure block-level layout */
            overflow-y: auto; /* Add vertical scrollbar when needed */
            /*max-height: 700px; !* Set maximum height for the code block *!*/
            word-wrap: normal; /* Prevent text wrapping to keep lines intact */
            white-space: pre; /* Preserve spaces and line breaks in code */
        }

        .reveal .highlight-blue-initially {
            color: blue;
        }

        /*.reveal .no-bullets {*/
        /*  list-style-type: none;*/
        /*}*/


        .reveal ul {
            list-style-type: none;
            padding: 0;
        }

        .reveal ul li {
            padding-left: 1.5em;
            position: relative;
        }

        /* Solid checkmark icon */
        .reveal ul li.check::before {
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            content: "\f00c";
            position: absolute;
            left: 0;
            top: 0;
            /*color: lightblue;*/
        }

        /* Star icon */
        .reveal ul li.star::before {
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            content: "\f005";
            position: absolute;
            left: 0;
            top: 0;
        }

        .slides {
            overflow-y: auto;
        }

        /* Center code blocks and add some shadow */
        .reveal .slides section .code-wrapper {
            width: 90%;
            margin: 20px auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
            border-radius: 8px; /* Added rounded corners */
            overflow: hidden; /* Ensure code doesn't overflow rounded corners */
        }

        /* Ensure code blocks are readable */
        .reveal .slides section pre code {
            max-height: 550px; /* Adjust as needed */
            font-size: 0.75em; /* Slightly smaller font size for more code */
            line-height: 1.3; /* Improve line spacing */
            border-radius: 0; /* Remove default radius from highlight.js */
        }

        /* Standardize text alignment and margins */
        .reveal h1, .reveal h2, .reveal h3, .reveal h4 {
            text-align: center;
            margin-bottom: 40px; /* More space below headings */
        }

        .reveal p, .reveal li {
            text-align: left;
            margin-left: 5%;
            margin-right: 5%;
        }

        .reveal ul, .reveal ol {
            margin-left: 5%;
            margin-right: 5%;
            width: 90%;
            display: block; /* Ensure lists take block space */
        }

        .reveal pre {
            margin: 0 auto; /* Center pre block */
            width: 100%; /* Make pre take full width of wrapper */
            box-shadow: none; /* Remove default shadow from pre */
        }

        /* Style for analogy boxes */
        .analogy {
            font-style: italic;
            background-color: #f0f8ff; /* Light AliceBlue background */
            padding: 20px;
            border-radius: 8px;
            margin: 25px 5%; /* Add more vertical margin */
            border-left: 5px solid #87ceeb; /* Sky blue border */
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1); /* Subtle shadow */
        }

        .analogy p {
            margin-left: 0; /* Reset margin for paragraphs inside analogy box */
            margin-right: 0;
        }

        /* Ensure table looks decent */
        .reveal table {
            margin: 30px auto;
            border-collapse: collapse;
            width: 90%;
        }

        .reveal th, .reveal td {
            border: 1px solid #ccc;
            padding: 10px;
            text-align: left;
        }

        .reveal th {
            background-color: #e0f2f7; /* Light cyan header */
        }

        .reveal small {
            display: block; /* Make small text block level */
            margin-top: 15px;
            text-align: center;
            font-style: italic;
        }
        .reveal .slides section .fragment.visible.highlight-green {
            color: green !important; /* Or background-color, etc. */
        }

        /* --- Custom Slide-in-from-Right Animation --- */

        /* Initial state: Off-screen to the right and invisible */
        .fragment.slide-right {
            opacity: 0;
            /* Start 100% of its own width to the right */
            transform: translateX(100%);
            /* Define the transition: property duration timing-function */
            /* Apply transition to the initial state */
            transition: transform 0.6s ease-out, opacity 0.6s ease-out !important;
            /* You might need !important to override theme styles */
        }

        /* Final state: When the fragment becomes visible */
        .fragment.slide-right.visible {
            opacity: 1;
            /* Move back to its original position (defined by layout) */
            transform: translateX(0);
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-auto-animate>
            <h3>Cleaner, More Expressive Java</h3>
            <h3>using Functors and Monads</h3>
            <p style="text-align: center;"><small>Magnus Smith</small></p>
            <aside class="notes">
                Welcome everyone. Today we'll dive into Functors and Monads, concepts from functional programming that
                are increasingly relevant in Java. Don't worry if they sound intimidating; we'll focus on intuition and
                practical examples.
            </aside>
        </section>
        <section data-auto-animate>
            <h3>Why Are We Here?</h3>
            <ul>
                <li class="fragment custom blur highlight-current-green" data-fragment-index="1">Functional programming concepts are relevant in Java.
                </li>
                <li class="fragment custom blur highlight-current-green" data-fragment-index="2">Functors and Monads
                    might sound intimidating when unfamiliar, but the underlying ideas are powerful and useful.
                </li>
            </ul>
            <aside class="notes">
                Why should you, as a Java developer, care about these? Because they help write cleaner, more robust
                code, especially when dealing with common problems like nulls, collections, or asynchronous operations.
                We'll see how Java already uses these patterns.
            </aside>
        </section>
        <section data-auto-animate>
            <h3>Goal: Functors + Monads</h3>
            <ul>
                <li class="fragment custom blur highlight-green check" data-fragment-index="1"> Understand <em>what</em> they are</li>
                <li class="fragment custom blur highlight-green check" data-fragment-index="2">See <em>how</em> they appear in Java</li>
                <li class="fragment custom blur highlight-green check" data-fragment-index="3">Learn <em>why</em> you might care.</li>
                <li class="fragment custom blur highlight-green check" data-fragment-index="4">Focus on intuition and practical application, not deep category theory.</li>
            </ul>
        </section>
        <section data-auto-animate>
            <h3>The Problem: Handling "Context"</h3>
            <p><em>Often, our values don't exist in isolation. They come with some form of "context":</em></p>
            <ul>
                <li class="fragment custom blur highlight-green check" data-fragment-index="1">Maybe the value
                    is present, maybe it's not.<br><span class="fragment custom blur highlight-red" data-fragment-index=2"><code>Optional&lt;T&gt;</code></span>
                </li>
                <li class="fragment custom blur highlight-green check" data-fragment-index="3" >It's one value
                    among many<br><span class="fragment custom blur highlight-red" data-fragment-index=4"><code>List&lt;T&gt;</code> or <code>Stream&lt;T&gt;</code></span>
                </li>
            </ul>
            <aside class="notes">
                Think about everyday Java code. You check for null, you iterate over lists, you handle futures. These
                all involve values wrapped in some kind of context. Manually managing this context can lead to
                boilerplate and errors.
            </aside>
        </section>
        <section data-auto-animate>
            <h3>The Problem: Handling "Context"</h3>
            <ul>
                <li class="fragment custom blur highlight-green check" data-fragment-index=1">It's a value that
                will arrive later<br><span class="fragment custom blur highlight-red" data-fragment-index=2"><code>CompletableFuture&lt;T&gt;</code></span>
                </li>
                <li class="fragment custom blur highlight-green check" data-fragment-index="3">It represents a
                    computation that might succeed or fail<br><span class="fragment custom blur highlight-red" data-fragment-index=4"><code>Result&lt;T&gt;</code> or
                    <code>Try&lt;T&gt;</code> types.</span>
                </li>
            </ul>
            <aside class="notes">
                Think about everyday Java code. You check for null, you iterate over lists, you handle futures. These
                all involve values wrapped in some kind of context. Manually managing this context can lead to
                boilerplate and errors.
            </aside>
        </section>
        <section data-auto-animate>
            <h3>The Challenge:</h3>
            <p class="fragment custom blur highlight-green check" data-fragment-index=1">How do we apply
                functions or transformations to the value(s) <em>inside</em> this context, without manually unpacking
                and repacking them every time?</p>
        </section>

        <section data-auto-animate>
            <h3>Functor</h3>
            <p><em>A design pattern for types that contain value(s).</em></p>
            <ul>
                <li class="fragment custom blur highlight-green" data-fragment-index="1">Container:<span
                        class="fragment custom blur highlight-red"
                        data-fragment-index="2"> The type that holds values</span>
                </li>
                <li class="fragment custom blur highlight-green" data-fragment-index="3">Function:<span
                        class="fragment custom blur highlight-red"
                        data-fragment-index="4"> A -> B</span>
                </li>
                <li class="fragment custom blur highlight-green" data-fragment-index="5">Functor:<span
                        class="fragment custom blur highlight-red"
                        data-fragment-index="6"> Transformation capability of the container</span>
                </li>
            </ul>
            <p class="fragment custom blur highlight-green" data-fragment-index=7">Provides a standard way to
                apply a function to the value(s) <em>without changing the context</em>.</p>

            <aside class="notes">
                In simple terms, a functor is a design pattern that allows you to apply a function to elements within a
                container without having to extract those elements manually. Think of it as a ‚Äúmappable‚Äù container.


                In Java terms:

                Container: This could be an Optional, a List, a Stream, or any other type that ‚Äúholds‚Äù values.
                Function: This is a transformation you want to apply to the values inside the container.
                Functor: This is the capability of the container to apply the function, producing a new container with
                the transformed values.

                Essentially, a functor provides a map operation that ‚Äúlifts‚Äù a function to work within the context of
                the container.

                The first pattern to help us is the Functor. Think of it as an interface (though not always a literal
                Java interface) for containers that says "I know how to apply a function to my contents". The magic is
                in the `map` method.
            </aside>
        </section>
        <section data-auto-animate>
            <h3>Functor</h3>
            <p><em>It lifts a function into the world of contexts.</em></p>

            <p class="fragment custom blur highlight-green" data-fragment-index=1">The transformation operation:
                <span
                        class="fragment custom blur highlight-red"
                        data-fragment-index="2"><code>map</code></span></p>
            <p class="fragment custom blur highlight-green" data-fragment-index=3"><code>map</code> takes a
                regular function <code>A -> B</code><span
                        class="fragment custom blur highlight-red"
                        data-fragment-index="4"> transforms <code>Functor&lt;A&gt;</code> to <code>Functor&lt;B&gt;</code>.</span>
            </p>
            <aside class="notes">
                In simple terms, a functor is a design pattern that allows you to apply a function to elements within a
                container without having to extract those elements manually. Think of it as a ‚Äúmappable‚Äù container.
                The first pattern to help us is the Functor. Think of it as an interface (though not always a literal
                Java interface) for containers that says "I know how to apply a function to my contents". The magic is
                in the `map` method.
            </aside>
        </section>
        <section data-auto-animate>
            <h3>Functor Analogy: Magic Box üéÅ</h3>
            <p>Imagine a sealed, transparent box containing a value</p>
            <p>You have a tool that can transform the value.</p>
            <p>The <code>map</code> operation is like having robotic arms.</p>
        </section>
        <section data-auto-animate data-background-transition="slide">
            <h3>Functor Analogy: Magic Box üéÅ</h3>

            <div style="display: flex; justify-content: space-around;">
                <img src="assets/f1_m1_x_in_box.png" alt="Image 1" class="fragment slide-left" style="width: 40%;">
                <img src="assets/f2_m2_robot_take_x_from_box.png" alt="Image 2" class="fragment slide-left" style="width: 40%;">
                <img src="assets/f3_m3_robot_input_x_to_function.png" alt="Image 3" class="fragment slide-left" style="width: 40%;">
                <img src="assets/function_x_to_y.png" alt="Image 4" class="fragment slide-left" style="width: 40%;">
            </div>

        </section>

        <section data-auto-animate>
            <h3>Functor Analogy: Magic Box üéÅ</h3>
            <p>You give the arms the tool, and they reach <em>inside</em> the box, use the tool on the item</p>
            <p>They place the <em>transformed</em> value into a <em>new</em>, identical sealed box.</p>
        </section>
        <section data-auto-animate>
            <h3>Functor: A Magic Box üéÅ</h3>
            <div style="display: flex; justify-content: space-around;">
                <img src="assets/function_x_to_y.png" alt="Image 4" class="fragment slide-left" style="width: 40%;">
                <img src="assets/f4_robot_take_y_from_function.png" alt="Image 1" class="fragment slide-left" style="width: 40%;">
                <img src="assets/f5_robot_add_y_to_box.png" alt="Image 1" class="fragment slide-left" style="width: 40%;">
                <img src="assets/f6_m8_y_in_box.png" alt="Image 2" class="fragment slide-left" style="width: 40%;">
            </div>
        </section>
        <section data-auto-animate>
            <h3>Functor: A Magic Box üéÅ</h3>
            <p>You never opened the original box, and you get back the same <em>type</em> of box, just potentially holding a different value.</p>
        </section>
        <section data-auto-animate>
            <h3>Functor: A Magic Box üéÅ</h3>
            <p>Context is preserved, the function operates inside, and you get a new context back.</p>
            <p>If the box was empty, the arms do nothing and return a new empty box.</p>
        </section>

        <section data-auto-animate>
            <h3>Functor: <code>Optional&lt;T&gt;</code></h3>
            <p class="fragment custom blur highlight-green">Context: <span
                    class="fragment custom blur highlight-current-red"><em>optionality</em></span></p>
            <div class="code-wrapper">
                <pre><code class="java" data-line-numbers data-noescape data-trim>
// Optional containing a String (context + value)
Optional&lt;String&gt; optName = Optional.of("Alice");

// Function: String -> Integer (length)
Function&lt;String, Integer&gt; nameLength = String::length;

// map applies the function *inside* the Optional context
// Input: Optional&lt;String&gt;, Function&lt;String, Integer>
// Output: Optional&lt;Integer&gt;
Optional&lt;Integer> optLength = optName.map(nameLength);

println(optLength); // Output: Optional[5]

// What if the Optional is empty?
Optional&lt;String&gt; emptyOpt = Optional.empty();
// Function is never called
Optional&lt;Integer&gt; emptyLength = emptyOpt.map(nameLength);
// Output: Optional.empty (context preserved)
println(emptyLength);
				</code></pre>
            </div>
            <aside class="notes">
                Here, `Optional` is the box. `map` applies `String::length` only if the box contains a String. The
                result is still an `Optional` box, now potentially containing an Integer. Notice how the null check is
                handled implicitly by `map`.
            </aside>
        </section>

        <section data-auto-animate>
            <h3>Functor: <code>Stream&lt;T&gt;</code></h3>
            <p class="fragment custom blur highlight-green">Context: <span
                    class="fragment custom blur highlight-current-red"><em>a sequence of elements</em></span></p>
            <div class="code-wrapper">
                <pre><code class="java" data-noescape data-trim data-line-numbers>

Stream&lt;String&gt; nameStream = Stream.of("Bob", "Charlie", "David");

// Function: String -> String (uppercase)
Function&lt;String, String&gt; toUpper = String::toUpperCase;

// map applies the function to each element *within* the Stream context
// Input: Stream&lt;String&gt;, Function&lt;String, String&gt;
// Output: Stream&lt;String&gt;
Stream&lt;String&gt; upperCaseStream = nameStream.map(toUpper);

upperCaseStream.forEach(System.out::println);
// BOB
// CHARLIE
// DAVID
                </code></pre>
            </div>
            <aside class="notes">
                For Streams, `map` applies the function to every element in the sequence.
                The context (`Stream`) is maintained; we get a new `Stream` containing the transformed elements.
                This is like the box analogy applied to multiple items in sequence.
                map transforms each element while preserving the Stream structure.
            </aside>
        </section>

        <section data-auto-animate>
            <h3>Functor Laws</h3>
            <p>For a type to be a <em>well-behaved</em> Functor, its <code>map</code> should obey two laws:</p>
            <p class="fragment custom blur highlight-green"><strong>1. Identity:</strong>
                <span class="fragment custom blur highlight-current-blue"><br><code>functor.map(x -> x)</code> should be equivalent to <code>functor</code>.</span>
            </p>

        </section>
        <section data-auto-animate>
            <h3>Functor Laws</h3>

            <p class="fragment custom blur highlight-green"><strong>2. Composition:</strong>
                <span class="fragment custom blur highlight-current-blue"><br>Mapping with two functions sequentially is the same as mapping with the composition of those functions.</span>
            </p>
            <p class="fragment custom blur highlight-current-blue"><code>functor.map(f).map(g)</code> is equivalent to
                <code>functor.map(x -> g(f(x)))</code><br></p>
            <aside class="notes">
                These laws might seem abstract, but they just guarantee that `map` doesn't do anything weird. It behaves
                predictably, like normal function application. `Optional` and `Stream` follow these laws.
                Mapping with the identity function (a function that returns its input unchanged) should result in an
                equivalent functor. In pseudo-code: functor.map(x -> x) is equivalent to functor.
                <p> Mapping with the identity function (<code>x -> x</code>) must not change the functor.</p>
            </aside>
        </section>
        <section data-auto-animate>
            <h3>The Problem with <code>map</code></h3>
            <p><em>What happens if the function we want to <code>map</code> <strong>also</strong> returns a value wrapped in the same
                context?</em></p>

            <p class="fragment custom blur highlight-green">Nested contexts: <span class="fragment custom blur highlight-current-red"><code>Optional&lt;Optional&lt;String&gt;&gt;</code></span></p>
        </section>
        <section data-auto-animate>
            <h3>The Problem with <code>map</code></h3>
            <div class="code-wrapper">
                <pre><code class="java" data-line-numbers data-trim>

// Function that looks up a userId and returns their User *as an Optional*
Optional&lt;User&gt; findUser(String userId) {
  // ... logic to fetch user from database or return Optional.empty() ...
}

Optional&lt;Address&gt; findAddress(User user) {
  // ... logic to fetch address, or return Optional.empty() if none ...
}

Optional&lt;User&gt; optUser =  findUser(String userId);
// Nested contexts: `Optional` and `Optional`
Optional&lt;Optional&lt;Address&gt;&gt; nestedOptAddress
                    = optUser.map(this::findAddress);

                </code></pre>
            </div>

            <aside class="notes">
                Here's where Functors fall short. If our transformation function itself returns a contextual value (like
                another Optional), `map` just wraps it again, leading to nested structures like `Optional&lt;Optional&lt;T&gt;&gt;`
                or `Stream&lt;Stream&lt;T&gt;&gt;`. This is often not what we want.
                <p>Uh oh! We get nested contexts: <code>Optional&lt;Optional&lt;String&gt;&gt;</code>. This quickly
                    becomes awkward to work with.</p>
            </aside>
        </section>

        <section data-auto-animate>
            <h3>Monad</h3>
            <p>A Monad <strong>is</strong> a Functor with <em>additional features</em>.</p>
            <p class="fragment custom blur highlight-green">It's a pattern designed specifically to handle:</p><br>
            <span class="fragment custom blur highlight-blue"><em>Sequences of operations where each step might return a value <strong>already
                wrapped</strong> in the context.</em></span>
            <aside class="notes">
                Monads build on Functors. They add the crucial `flatMap` operation. `flatMap` is like `map`, but it's
                specifically for functions that *already* return a monadic value. Its superpower is preventing the
                nesting we just saw.
            </aside>
        </section>
        <section data-auto-animate>
            <h3>Monad</h3>
            <p class="fragment custom blur highlight-green" data-fragment-index=1">The key operation:<span
                    class="fragment custom blur highlight-red"
                    data-fragment-index="2"><code>flatMap</code></span></p>
            <p class="fragment custom blur highlight-current-green" data-fragment-index=3"><code>f: A -> Monad&lt;B&gt;</code>
                <span class="fragment custom blur highlight-current-blue" data-fragment-index="4"><br>flatMap transforms
                    <br><code>Monad&lt;A&gt;</code> to <code>Monad&lt;B&gt;</code>.</span></p>
            <p  class="fragment custom blur highlight-current-blue" data-fragment-index="5" >Crucially, it <em>maps</em> then <strong>flattens</strong> the result, avoiding the nesting problem!</p>
            <aside class="notes">
                Monads build on Functors. They add the crucial `flatMap` operation. `flatMap` is like `map`, but it's
                specifically for functions that *already* return a monadic value. Its superpower is preventing the
                nesting we just saw.
                <p>Key method: <code>flatMap</code> (or <code>bind</code>, <code>chain</code> in other languages)</p>
                <p><code>flatMap</code> takes a function <code>A -> Monad&lt;B&gt;</code> and transforms a <code>Monad&lt;A&gt;</code>
                    into a <code>Monad&lt;B&gt;</code>.</p>

            </aside>
        </section>
        <section data-auto-animate>
            <h3>Monad</h3>
			<p class="fragment custom blur highlight-green" data-fragment-index=1">Lift a value into the context: <span
					class="fragment custom blur highlight-red"
					data-fragment-index="2"><code>of</code></span></p>
            <p class="fragment custom blur highlight-current-blue" data-fragment-index="3">In Java, typically static factory methods like <span class="fragment custom blur highlight-current-blue" data-fragment-index=4>
                <code>Optional.of()</code>, <code>Stream.of()</code>.</span></p>
            <aside class="notes">
                Monads build on Functors. They add the crucial `flatMap` operation. `flatMap` is like `map`, but it's
                specifically for functions that *already* return a monadic value. Its superpower is preventing the
                nesting we just saw.
				<p>Monads also need a way to wrap a plain value into the context.
					In Java, typically static factory methods like <code>Optional.of()</code>, <code>Stream.of()</code>.</p>
            </aside>
        </section>
        <section data-auto-animate>
            <h3>Monad Analogy: The Smart Box üéÅ‚û°Ô∏èüéÅ</h3>
            <p>Now, the function <em>itself</em> produces a <em>new</em> sealed box containing the result</p><br>
            <code>f: User -> Optional&lt;Address&gt;</code>
            <p>If you just used <code>map</code> (the Functor way), you'd get a box containing another box (<code>Optional&lt;Optional&lt;Address&gt;&gt;</code>).</p>
            <aside class="notes">
                The key difference in the analogy is that `flatMap` knows how to handle functions that return *another
                box*. It performs the function and then intelligently merges the result back into a single layer of
                context.
            </aside>
        </section>
        <section data-auto-animate>
            <h3>Monad: A Smart Box üéÅ‚û°Ô∏èüéÅ</h3>
            <div style="display: flex; justify-content: space-around;">
                <img src="assets/f1_m1_x_in_box.png" alt="Image 1" class="fragment slide-left" style="width: 20%;">
                <img src="assets/f2_m2_robot_take_x_from_box.png" alt="Image 2" class="fragment slide-left" style="width: 40%;">
                <img src="assets/f3_m3_robot_input_x_to_function.png" alt="Image 3" class="fragment slide-left" style="width: 40%;">
                <img src="assets/function_x_to_boxed_y.png" alt="Image 4" class="fragment slide-left" style="width: 40%;">
            </div>
        </section>
        <section data-auto-animate>
            <h3>Monad: A Smart Box üéÅ‚û°Ô∏èüéÅ</h3>
            <p>The <code>flatMap</code> operation is smarter:</p>
            <ol>
                <li>It applies the function inside the first box to get the <em>new inner box</em>.</li>
                <li>It then <em>unpacks</em> this new inner box.</li>
                <li>It takes the value from the inner box and puts it directly into a new same type box.
                </li>
            </ol>

            <p>It effectively <em>flattens</em> <code>Box&lt;Box&lt;Item&gt;&gt;</code> into just <code>Box&lt;Item&gt;</code>.
            </p>
            <aside class="notes">
                The key difference in the analogy is that `flatMap` knows how to handle functions that return another
                box*. It performs the function and then intelligently merges the result back into a single layer of
                context.
            </aside>
        </section>
        <section data-auto-animate>
            <h3>Monad: A Smart Box üéÅ‚û°Ô∏èüéÅ</h3>
            <div style="display: flex; justify-content: space-around;">
                <img src="assets/m4_robot_take_boxed_y_from_function.png" alt="Image 1" class="fragment slide-left" style="width: 40%;">
                <img src="assets/m5_robot_add_boxed_y_to_box.png" alt="Image 2" class="fragment slide-left" style="width: 40%;">
                <img src="assets/m6_y_in_box_in_a_box.png" alt="Image 3" class="fragment slide-left" style="width: 40%;">
                <img src="assets/m7_robots_removing_boxed_y_from_box.png" alt="Image 4" class="fragment slide-left" style="width: 40%;">
                <img src="assets/f6_m8_y_in_box.png" alt="Image 5" class="fragment slide-left" style="width: 40%;">
            </div>
        </section>

        <section data-auto-animate>
            <h3>Monad: <code>Optional</code></h3>
            <p><span class="fragment custom blur highlight-current-blue" data-fragment-index="1"><code>Optional</code> is a Monad</span><span class="fragment custom blur highlight-red"  data-fragment-index="2"> => <code>flatMap</code></span>
            <div class="code-wrapper fragment" data-fragment-index="3">
                <pre><code class="java" data-line-numbers data-trim>
Optional&lt;User&gt; findUser(String userId) {
  // ... logic to fetch user from database or return Optional.empty() ...
}

Optional&lt;Address&gt; findAddress(User user) {
  // ... logic to fetch address, or return Optional.empty() if none ...
}

Optional&lt;User&gt; optUser =  findUser(String userId);
// Use flatMap when the function returns an Optional!
// Input: Optional&lt;User&gt;, Function&lt;User, Optional&lt;Address&gt;&gt;
// Output: Optional&lt;Address&gt; (Flattened!)
Optional&lt;Address&gt; nestedOptAddress
                    = optUser.flatMap(this::findAddress);
                </code></pre>
            </div>
            <p class="fragment custom blur highlight-current-blue" data-fragment-index="4"><code>flatMap</code> allows chaining operations that might return empty Optionals.</p>
        </section>

        <section data-auto-animate>
            <h3>Monad: <code>Stream</code></h3>
            <p><span class="fragment custom blur highlight-current-blue" data-fragment-index="1"><code>Stream</code> is a Monad</span><span class="fragment custom blur highlight-red"  data-fragment-index="2"> => <code>flatMap</code></span></p>
            <div class="code-wrapper fragment" data-fragment-index="3">
                <pre><code class="java" data-trim>
// A list where each element is itself a list of Strings
List&lt;List&lt;String&gt;&gt; listOfLists = asList(asList("a", "b"),
                                        asList("c", "d", "e"));

// Function: List&lt;String&gt; -> Stream&lt;String&gt; (returns a Stream - a Monad!)
Function&lt;List&lt;String&gt;, Stream&lt;String&gt;&gt; listToStream = List::stream;

// Using map creates a Stream of Streams (nested context)
// Output type: Stream&lt;Stream&lt;String&gt;&gt;
Stream&lt;Stream&lt;String&gt;&gt; nestedStream = listOfLists.stream().map(listToStream);

// Using flatMap flattens the result into a single Stream
// Input: Stream&lt;List&lt;String&gt;&gt;, Function&lt;List&lt;String&gt;, Stream&lt;String&gt;&gt;
// Output: Stream&lt;String&gt; (Flattened!)
Stream&lt;String&gt; flattenedStream = listOfLists.stream().flatMap(listToStream);

flattenedStream.forEach(s -> System.out.print(s + " ")); // Output: a b c d e</code></pre>
            </div>
            <p class="fragment custom blur highlight-current-blue" data-fragment-index="4"><code>flatMap</code> is essential for flattening nested collections or streams.</p>
            <aside class="notes">
                For Streams, `flatMap` is used when your transformation function takes one element and produces
                *multiple* elements (represented as another Stream or Collection). `flatMap` takes all the resulting
                streams and concatenates them into one single, flat stream. Very useful for data processing.
            </aside>
        </section>

        <section data-auto-animate>
            <h3>Monad Laws: <code>flatMap</code></h3>
            <p class="fragment custom blur highlight-green" data-fragment-index="0"><strong>1. Left Identity:</strong></p>
            <p class="fragment custom blur highlight-current-blue" data-fragment-index="1"><em>Wrapping a value then flatMapping <code>f</code> is the same as just applying<code>f</code> to the value.</em></p>
            <p class="fragment custom blur highlight-red" data-fragment-index="2"><code>Monad.of(x).flatMap(f) <=> f(x)</code>
        </p>
        </section>
        <section data-auto-animate>
            <h3>Monad Laws: <code>flatMap</code></h3>
            <p class="fragment custom blur highlight-green" data-fragment-index="0"><strong>2. Right Identity:</strong></p>
            <p class="fragment custom blur highlight-current-blue" data-fragment-index="1"><em>FlatMapping with the wrapping function <code>Monad::of</code> doesn't change the monad.</em></p>
            <p class="fragment custom blur highlight-red" data-fragment-index="2"><code>m.flatMap(Monad::of) <=> m</code></p>
            <aside class="notes">
                Again, don't get bogged down by the formulas. The essence is that `flatMap` allows reliable, predictable
                chaining of operations within the monadic context. These laws guarantee that chaining works as you'd
                intuitively expect.
            </aside>
        </section>
        <section data-auto-animate>
            <h3>Monad Laws: <code>flatMap</code></h3>
            <p class="fragment custom blur highlight-green" data-fragment-index="0"><strong>3. Associativity:</strong></p>
            <p class="fragment custom blur highlight-current-blue" data-fragment-index="1"><em>How you group chained <code>flatMap</code> calls doesn't matter.</em></p>
            <p class="fragment custom blur highlight-red" data-fragment-index="2"><code>m.flatMap(f).flatMap(g) <=> m.flatMap(x -> f(x).flatMap(g))</code></p>
            <aside class="notes">
                <small>(You don't usually need to *prove* these, but rely on library types like `Optional` and `Stream`
                    obeying them.)</small>
            </aside>
        </section>

        <section data-auto-animate>
            <h3>Functor vs Monad</h3>
            <p><em>Core Idea:</em></p>
            <p data-id="functor-label-1" class="fragment custom blur highlight-green" data-fragment-index="0"><strong>Functor:</strong></p>
            <p data-id="functor-desc-1" class="fragment custom blur highlight-current-blue" data-fragment-index="1"><em>Mapping over a context.</em></p>
            <p data-id="monad-label-1" class="fragment custom blur highlight-green" data-fragment-index="2"><strong>Monad:</strong></p>
            <p data-id="monad-desc-1" class="fragment custom blur highlight-current-blue" data-fragment-index="3"><em>Sequencing/Chaining operations within a context</em></p>
        </section>

        <section data-auto-animate>
            <h3>Functor vs Monad</h3>
            <p><em>Key Method(s):</em></p>
            <p data-id="functor-label-2" class="fragment custom blur highlight-green" data-fragment-index="0"><strong>Functor:</strong></p>
            <p data-id="functor-desc-2" class="fragment custom blur highlight-current-blue" data-fragment-index="1"><em><code>map(A -> B)</code></em></p>
            <p data-id="monad-label-2" class="fragment custom blur highlight-green" data-fragment-index="2"><strong>Monad:</strong></p>
            <p data-id="monad-desc-2" class="fragment custom blur highlight-current-blue" data-fragment-index="3"><em><code>flatMap(A -> Monad&lt;B&gt;)</code> <br>+ <code>map(A -> B)</code> <br>+ <code>of(A -> Monad&lt;A&gt;)</code></em></p>
        </section>

        <section data-auto-animate>
            <h3>Functor vs Monad</h3>
            <p><em>Handles Function Returning...</em></p>
            <p  data-id="functor-label-3" class="fragment custom blur highlight-green" data-fragment-index="0"><strong>Functor:</strong></p>
            <p data-id="functor-desc-3" class="fragment custom blur highlight-current-blue" data-fragment-index="1"><em>Plain value</em></p>
            <p data-id="monad-label-3" class="fragment custom blur highlight-green" data-fragment-index="2"><strong>Monad:</strong></p>
            <p data-id="monad-desc-3" class="fragment custom blur highlight-current-blue" data-fragment-index="3"><em>Contextual value <code>Monad&lt;B&gt;</code></em></p>
        </section>

        <section  data-auto-animate>
            <h3>Functor vs Monad</h3>
            <p><em>Result of applying <code>Fn(A -> Context&lt;B&gt;)</code></em><p>
            <p data-id="functor-label-4" class="fragment custom blur highlight-green" data-fragment-index="0"><strong>Functor:</strong></p>
            <p data-id="functor-desc-4" class="fragment custom blur highlight-current-blue" data-fragment-index="1"><em><code>Context&lt;Context&lt;B&gt;&gt;</code> (via <code>map</code>)</em></p>
            <p data-id="monad-label-4" class="fragment custom blur highlight-green" data-fragment-index="2"><strong>Monad:</strong></p>
            <p data-id="monad-desc-4" class="fragment custom blur highlight-current-blue" data-fragment-index="3"><em><code>Context&lt;B&gt;</code> (via <code>flatMap</code>)</em></p>
        </section>

        <section data-auto-animate>
            <h3>Functor vs Monad</h3>
            <p><em>Analogy:</em></p>
            <p data-id="functor-label-5" class="fragment custom blur highlight-green" data-fragment-index="0"><strong>Functor:</strong></p>
            <p data-id="functor-desc-5" class="fragment custom blur highlight-current-blue" data-fragment-index="1"><em>Box + Tool (map)</em></p>
            <p data-id="monad-label-5" class="fragment custom blur highlight-green" data-fragment-index="3"><strong>Monad:</strong></p>
            <p data-id="monad-desc-5" class="fragment custom blur highlight-current-blue" data-fragment-index="4"><em>Smart Box + Tool that returns Box (flatMap)</em></p>
            <p data-id="functor-monad-5" class="fragment custom blur highlight-blue" data-fragment-index="5"><strong><em>All Monads are Functors, but not all Functors are
                Monads.</em></strong></p>
        </section>

        <section data-auto-animate>
            <h3>Benefits in Java</h3>
            <p class="fragment custom blur highlight-green" data-fragment-index="0"><strong>Cleaner Null Handling:</strong></p>
            <p class="fragment custom blur highlight-current-blue" data-fragment-index="1"><code>Optional.map</code>/<code>flatMap</code> chains avoid deep nesting of <code>if (x != null)</code> checks.</p>
            <p class="fragment custom blur highlight-blue" data-fragment-index="2"><em>Code becomes more linear and readable.</em></p>
        </section>
        <section data-auto-animate>
            <h3>Benefits in Java</h3>
            <p class="fragment custom blur highlight-green" data-fragment-index="0"><strong>Simplified Asynchronous Code:</strong></p>
            <p class="fragment custom blur highlight-current-blue" data-fragment-index="1"><code>CompletableFuture.thenApply</code> (map) / <code>thenCompose</code> (flatMap).</p>
            <p class="fragment custom blur highlight-blue" data-fragment-index="2"><em>chain async operations without complex callback management => "callback hell".</em></p>
        </section>
        <section data-auto-animate>
            <h3>Benefits in Java</h3>
            <p class="fragment custom blur highlight-green" data-fragment-index="0"><strong>Declarative Data Pipelines:</strong></p>
            <p class="fragment custom blur highlight-current-blue" data-fragment-index="1"><code>Stream.map</code>/<code>flatMap</code> </p>
            <p class="fragment custom blur highlight-blue" data-fragment-index="2"><em>build complex data transformations concisely and expressively.</em></p>
        </section>
        <section data-auto-animate>
            <h3>Benefits in Java</h3>
            <p class="fragment custom blur highlight-green" data-fragment-index="1"><strong>Reduced Boilerplate:</strong></p>
            <p class="fragment custom blur highlight-blue" data-fragment-index="2"><em>Abstracting the "context handling" logic (checking for presence, iterating, handling async results) into reusable methods.</em></p>
            <p class="fragment custom blur highlight-green" data-fragment-index="3"><strong>Improved Readability & Intent:</strong></p>
            <p class="fragment custom blur highlight-blue" data-fragment-index="4"><em>Code clearly expresses a sequence of operations or transformations.</em></p>
            <aside class="notes">
                So, why use these patterns? They lead to code that is often shorter, easier to read, less prone to
                certain errors (like NullPointerExceptions), and better at expressing complex workflows, especially with
                Java 8+ features.
            </aside>
        </section>

        <section data-auto-animate>
            <h3>Conclusion</h3>
            <p class="fragment custom blur highlight-green" data-fragment-index="1"><strong>Functors:</strong><span class="fragment custom blur highlight-blue" data-fragment-index="2"> Contexts you can <code>map</code> over.</span></p>
            <p class="fragment custom blur highlight-green" data-fragment-index="3"><strong>Monads:</strong><span  class="fragment custom blur highlight-blue" data-fragment-index="4"> Functors you can also <code>flatMap</code> over.</span></p>
            <aside class="notes">
                To wrap up: Functors let you apply functions inside contexts. Monads let you chain functions that return
                contexts, keeping the structure flat. You're likely already using them via Optional, Stream, and
                CompletableFuture. Recognizing the pattern helps you use them more effectively.
            </aside>
        </section>

        <section data-auto-animate>
            <h3>Conclusion</h3>

            <p class="fragment custom blur highlight-green" data-fragment-index="1">Common Java examples: <br>
            <p class="fragment custom blur highlight-red" data-fragment-index="2"><code>Optional</code>, <code>Stream</code>, <code>CompletableFuture</code></p>

            <p class="fragment custom blur highlight-current-blue" data-fragment-index="3"><em>They provide structured ways to manage "context" (optionality, collections, async results).</em></p>
            <p class="fragment custom blur highlight-blue" data-fragment-index="4"><em>Understanding them helps write cleaner, more robust, and more expressive Java code.</em></p>

            <aside class="notes">
                To wrap up: Functors let you apply functions inside contexts. Monads let you chain functions that return
                contexts, keeping the structure flat. You're likely already using them via Optional, Stream, and
                CompletableFuture. Recognizing the pattern helps you use them more effectively.
            </aside>
        </section>

        <section data-auto-animate>
            <h3>Questions?</h3>
            <img data-src="https://placehold.co/600x400/87CEEB/FFFFFF?text=Any+Questions%3F" alt="Q&A Placeholder"
                 style="border: none; box-shadow: none; margin-top: 40px;">
        </section>

    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
</html>
